{"ast":null,"code":"import { Quaternion } from \"../math/Quaternion.js\";\nimport { Vector3 } from \"../math/Vector3.js\";\nimport { Matrix4 } from \"../math/Matrix4.js\";\nimport { EventDispatcher } from \"./EventDispatcher.js\";\nimport { Euler } from \"../math/Euler.js\";\nimport { Layers } from \"./Layers.js\";\nimport { Matrix3 } from \"../math/Matrix3.js\";\nimport { MathUtils } from \"../math/MathUtils.js\";\nlet _object3DId = 0;\n\nconst _v1 = new Vector3();\n\nconst _q1 = new Quaternion();\n\nconst _m1 = new Matrix4();\n\nconst _target = new Vector3();\n\nconst _position = new Vector3();\n\nconst _scale = new Vector3();\n\nconst _quaternion = new Quaternion();\n\nconst _xAxis = new Vector3(1, 0, 0);\n\nconst _yAxis = new Vector3(0, 1, 0);\n\nconst _zAxis = new Vector3(0, 0, 1);\n\nconst _addedEvent = {\n  type: \"added\"\n};\nconst _removedEvent = {\n  type: \"removed\"\n};\n\nfunction Object3D() {\n  Object.defineProperty(this, \"id\", {\n    value: _object3DId++\n  });\n  this.uuid = MathUtils.generateUUID();\n  this.name = \"\";\n  this.type = \"Object3D\";\n  this.parent = null;\n  this.children = [];\n  this.up = Object3D.DefaultUp.clone();\n  const position = new Vector3();\n  const rotation = new Euler();\n  const quaternion = new Quaternion();\n  const scale = new Vector3(1, 1, 1);\n\n  function onRotationChange() {\n    quaternion.setFromEuler(rotation, false);\n  }\n\n  function onQuaternionChange() {\n    rotation.setFromQuaternion(quaternion, undefined, false);\n  }\n\n  rotation._onChange(onRotationChange);\n\n  quaternion._onChange(onQuaternionChange);\n\n  Object.defineProperties(this, {\n    position: {\n      configurable: true,\n      enumerable: true,\n      value: position\n    },\n    rotation: {\n      configurable: true,\n      enumerable: true,\n      value: rotation\n    },\n    quaternion: {\n      configurable: true,\n      enumerable: true,\n      value: quaternion\n    },\n    scale: {\n      configurable: true,\n      enumerable: true,\n      value: scale\n    },\n    modelViewMatrix: {\n      value: new Matrix4()\n    },\n    normalMatrix: {\n      value: new Matrix3()\n    }\n  });\n  this.matrix = new Matrix4();\n  this.matrixWorld = new Matrix4();\n  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n  this.matrixWorldNeedsUpdate = false;\n  this.layers = new Layers();\n  this.visible = true;\n  this.castShadow = false;\n  this.receiveShadow = false;\n  this.frustumCulled = true;\n  this.renderOrder = 0;\n  this.userData = {};\n}\n\nObject3D.DefaultUp = new Vector3(0, 1, 0);\nObject3D.DefaultMatrixAutoUpdate = true;\nObject3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: Object3D,\n  isObject3D: true,\n  onBeforeRender: function () {},\n  onAfterRender: function () {},\n  applyMatrix4: function (matrix) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    this.matrix.premultiply(matrix);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  },\n  applyQuaternion: function (q) {\n    this.quaternion.premultiply(q);\n    return this;\n  },\n  setRotationFromAxisAngle: function (axis, angle) {\n    // assumes axis is normalized\n    this.quaternion.setFromAxisAngle(axis, angle);\n  },\n  setRotationFromEuler: function (euler) {\n    this.quaternion.setFromEuler(euler, true);\n  },\n  setRotationFromMatrix: function (m) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    this.quaternion.setFromRotationMatrix(m);\n  },\n  setRotationFromQuaternion: function (q) {\n    // assumes q is normalized\n    this.quaternion.copy(q);\n  },\n  rotateOnAxis: function (axis, angle) {\n    // rotate object on axis in object space\n    // axis is assumed to be normalized\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.multiply(_q1);\n    return this;\n  },\n  rotateOnWorldAxis: function (axis, angle) {\n    // rotate object on axis in world space\n    // axis is assumed to be normalized\n    // method assumes no rotated parent\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.premultiply(_q1);\n    return this;\n  },\n  rotateX: function (angle) {\n    return this.rotateOnAxis(_xAxis, angle);\n  },\n  rotateY: function (angle) {\n    return this.rotateOnAxis(_yAxis, angle);\n  },\n  rotateZ: function (angle) {\n    return this.rotateOnAxis(_zAxis, angle);\n  },\n  translateOnAxis: function (axis, distance) {\n    // translate object by distance along axis in object space\n    // axis is assumed to be normalized\n    _v1.copy(axis).applyQuaternion(this.quaternion);\n\n    this.position.add(_v1.multiplyScalar(distance));\n    return this;\n  },\n  translateX: function (distance) {\n    return this.translateOnAxis(_xAxis, distance);\n  },\n  translateY: function (distance) {\n    return this.translateOnAxis(_yAxis, distance);\n  },\n  translateZ: function (distance) {\n    return this.translateOnAxis(_zAxis, distance);\n  },\n  localToWorld: function (vector) {\n    return vector.applyMatrix4(this.matrixWorld);\n  },\n  worldToLocal: function (vector) {\n    return vector.applyMatrix4(_m1.getInverse(this.matrixWorld));\n  },\n  lookAt: function (x, y, z) {\n    // This method does not support objects having non-uniformly-scaled parent(s)\n    if (x.isVector3) {\n      _target.copy(x);\n    } else {\n      _target.set(x, y, z);\n    }\n\n    const parent = this.parent;\n    this.updateWorldMatrix(true, false);\n\n    _position.setFromMatrixPosition(this.matrixWorld);\n\n    if (this.isCamera || this.isLight) {\n      _m1.lookAt(_position, _target, this.up);\n    } else {\n      _m1.lookAt(_target, _position, this.up);\n    }\n\n    this.quaternion.setFromRotationMatrix(_m1);\n\n    if (parent) {\n      _m1.extractRotation(parent.matrixWorld);\n\n      _q1.setFromRotationMatrix(_m1);\n\n      this.quaternion.premultiply(_q1.inverse());\n    }\n  },\n  add: function (object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    if (object === this) {\n      console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n      return this;\n    }\n\n    if (object && object.isObject3D) {\n      if (object.parent !== null) {\n        object.parent.remove(object);\n      }\n\n      object.parent = this;\n      this.children.push(object);\n      object.dispatchEvent(_addedEvent);\n    } else {\n      console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\n    }\n\n    return this;\n  },\n  remove: function (object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n\n      return this;\n    }\n\n    const index = this.children.indexOf(object);\n\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n      object.dispatchEvent(_removedEvent);\n    }\n\n    return this;\n  },\n  attach: function (object) {\n    // adds object as a child of this, while maintaining the object's world transform\n    this.updateWorldMatrix(true, false);\n\n    _m1.getInverse(this.matrixWorld);\n\n    if (object.parent !== null) {\n      object.parent.updateWorldMatrix(true, false);\n\n      _m1.multiply(object.parent.matrixWorld);\n    }\n\n    object.applyMatrix4(_m1);\n    object.updateWorldMatrix(false, false);\n    this.add(object);\n    return this;\n  },\n  getObjectById: function (id) {\n    return this.getObjectByProperty(\"id\", id);\n  },\n  getObjectByName: function (name) {\n    return this.getObjectByProperty(\"name\", name);\n  },\n  getObjectByProperty: function (name, value) {\n    if (this[name] === value) return this;\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      const child = this.children[i];\n      const object = child.getObjectByProperty(name, value);\n\n      if (object !== undefined) {\n        return object;\n      }\n    }\n\n    return undefined;\n  },\n  getWorldPosition: function (target) {\n    if (target === undefined) {\n      console.warn(\"THREE.Object3D: .getWorldPosition() target is now required\");\n      target = new Vector3();\n    }\n\n    this.updateMatrixWorld(true);\n    return target.setFromMatrixPosition(this.matrixWorld);\n  },\n  getWorldQuaternion: function (target) {\n    if (target === undefined) {\n      console.warn(\"THREE.Object3D: .getWorldQuaternion() target is now required\");\n      target = new Quaternion();\n    }\n\n    this.updateMatrixWorld(true);\n    this.matrixWorld.decompose(_position, target, _scale);\n    return target;\n  },\n  getWorldScale: function (target) {\n    if (target === undefined) {\n      console.warn(\"THREE.Object3D: .getWorldScale() target is now required\");\n      target = new Vector3();\n    }\n\n    this.updateMatrixWorld(true);\n    this.matrixWorld.decompose(_position, _quaternion, target);\n    return target;\n  },\n  getWorldDirection: function (target) {\n    if (target === undefined) {\n      console.warn(\"THREE.Object3D: .getWorldDirection() target is now required\");\n      target = new Vector3();\n    }\n\n    this.updateMatrixWorld(true);\n    const e = this.matrixWorld.elements;\n    return target.set(e[8], e[9], e[10]).normalize();\n  },\n  raycast: function () {},\n  traverse: function (callback) {\n    callback(this);\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  },\n  traverseVisible: function (callback) {\n    if (this.visible === false) return;\n    callback(this);\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  },\n  traverseAncestors: function (callback) {\n    const parent = this.parent;\n\n    if (parent !== null) {\n      callback(parent);\n      parent.traverseAncestors(callback);\n    }\n  },\n  updateMatrix: function () {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n    this.matrixWorldNeedsUpdate = true;\n  },\n  updateMatrixWorld: function (force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n      force = true;\n    } // update children\n\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].updateMatrixWorld(force);\n    }\n  },\n  updateWorldMatrix: function (updateParents, updateChildren) {\n    const parent = this.parent;\n\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.parent === null) {\n      this.matrixWorld.copy(this.matrix);\n    } else {\n      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    } // update children\n\n\n    if (updateChildren === true) {\n      const children = this.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateWorldMatrix(false, true);\n      }\n    }\n  },\n  toJSON: function (meta) {\n    // meta is a string when called from JSON.stringify\n    const isRootObject = meta === undefined || typeof meta === \"string\";\n    const output = {}; // meta is a hash used to collect geometries, materials.\n    // not providing it implies that this is the root object\n    // being serialized.\n\n    if (isRootObject) {\n      // initialize meta obj\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {}\n      };\n      output.metadata = {\n        version: 4.5,\n        type: \"Object\",\n        generator: \"Object3D.toJSON\"\n      };\n    } // standard Object3D serialization\n\n\n    const object = {};\n    object.uuid = this.uuid;\n    object.type = this.type;\n    if (this.name !== \"\") object.name = this.name;\n    if (this.castShadow === true) object.castShadow = true;\n    if (this.receiveShadow === true) object.receiveShadow = true;\n    if (this.visible === false) object.visible = false;\n    if (this.frustumCulled === false) object.frustumCulled = false;\n    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n    if (JSON.stringify(this.userData) !== \"{}\") object.userData = this.userData;\n    object.layers = this.layers.mask;\n    object.matrix = this.matrix.toArray();\n    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties\n\n    if (this.isInstancedMesh) {\n      object.type = \"InstancedMesh\";\n      object.count = this.count;\n      object.instanceMatrix = this.instanceMatrix.toJSON();\n    } //\n\n\n    function serialize(library, element) {\n      if (library[element.uuid] === undefined) {\n        library[element.uuid] = element.toJSON(meta);\n      }\n\n      return element.uuid;\n    }\n\n    if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = serialize(meta.geometries, this.geometry);\n      const parameters = this.geometry.parameters;\n\n      if (parameters !== undefined && parameters.shapes !== undefined) {\n        const shapes = parameters.shapes;\n\n        if (Array.isArray(shapes)) {\n          for (let i = 0, l = shapes.length; i < l; i++) {\n            const shape = shapes[i];\n            serialize(meta.shapes, shape);\n          }\n        } else {\n          serialize(meta.shapes, shapes);\n        }\n      }\n    }\n\n    if (this.material !== undefined) {\n      if (Array.isArray(this.material)) {\n        const uuids = [];\n\n        for (let i = 0, l = this.material.length; i < l; i++) {\n          uuids.push(serialize(meta.materials, this.material[i]));\n        }\n\n        object.material = uuids;\n      } else {\n        object.material = serialize(meta.materials, this.material);\n      }\n    } //\n\n\n    if (this.children.length > 0) {\n      object.children = [];\n\n      for (let i = 0; i < this.children.length; i++) {\n        object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n\n    if (isRootObject) {\n      const geometries = extractFromCache(meta.geometries);\n      const materials = extractFromCache(meta.materials);\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const shapes = extractFromCache(meta.shapes);\n      if (geometries.length > 0) output.geometries = geometries;\n      if (materials.length > 0) output.materials = materials;\n      if (textures.length > 0) output.textures = textures;\n      if (images.length > 0) output.images = images;\n      if (shapes.length > 0) output.shapes = shapes;\n    }\n\n    output.object = object;\n    return output; // extract data from the cache hash\n    // remove metadata on each item\n    // and return as array\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n  },\n  clone: function (recursive) {\n    return new this.constructor().copy(this, recursive);\n  },\n  copy: function (source, recursive) {\n    if (recursive === undefined) recursive = true;\n    this.name = source.name;\n    this.up.copy(source.up);\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n\n    return this;\n  }\n});\nexport { Object3D };","map":{"version":3,"sources":["/Users/mac/Documents/react/react-three/react-three/src/Object3D.js"],"names":["Quaternion","Vector3","Matrix4","EventDispatcher","Euler","Layers","Matrix3","MathUtils","_object3DId","_v1","_q1","_m1","_target","_position","_scale","_quaternion","_xAxis","_yAxis","_zAxis","_addedEvent","type","_removedEvent","Object3D","Object","defineProperty","value","uuid","generateUUID","name","parent","children","up","DefaultUp","clone","position","rotation","quaternion","scale","onRotationChange","setFromEuler","onQuaternionChange","setFromQuaternion","undefined","_onChange","defineProperties","configurable","enumerable","modelViewMatrix","normalMatrix","matrix","matrixWorld","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","layers","visible","castShadow","receiveShadow","frustumCulled","renderOrder","userData","prototype","assign","create","constructor","isObject3D","onBeforeRender","onAfterRender","applyMatrix4","updateMatrix","premultiply","decompose","applyQuaternion","q","setRotationFromAxisAngle","axis","angle","setFromAxisAngle","setRotationFromEuler","euler","setRotationFromMatrix","m","setFromRotationMatrix","setRotationFromQuaternion","copy","rotateOnAxis","multiply","rotateOnWorldAxis","rotateX","rotateY","rotateZ","translateOnAxis","distance","add","multiplyScalar","translateX","translateY","translateZ","localToWorld","vector","worldToLocal","getInverse","lookAt","x","y","z","isVector3","set","updateWorldMatrix","setFromMatrixPosition","isCamera","isLight","extractRotation","inverse","object","arguments","length","i","console","error","remove","push","dispatchEvent","index","indexOf","splice","attach","getObjectById","id","getObjectByProperty","getObjectByName","l","child","getWorldPosition","target","warn","updateMatrixWorld","getWorldQuaternion","getWorldScale","getWorldDirection","e","elements","normalize","raycast","traverse","callback","traverseVisible","traverseAncestors","compose","force","multiplyMatrices","updateParents","updateChildren","toJSON","meta","isRootObject","output","geometries","materials","textures","images","shapes","metadata","version","generator","JSON","stringify","mask","toArray","isInstancedMesh","count","instanceMatrix","serialize","library","element","isMesh","isLine","isPoints","geometry","parameters","Array","isArray","shape","material","uuids","extractFromCache","cache","values","key","data","recursive","source","order","parse"],"mappings":"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","sourcesContent":["import { Quaternion } from \"../math/Quaternion.js\";\nimport { Vector3 } from \"../math/Vector3.js\";\nimport { Matrix4 } from \"../math/Matrix4.js\";\nimport { EventDispatcher } from \"./EventDispatcher.js\";\nimport { Euler } from \"../math/Euler.js\";\nimport { Layers } from \"./Layers.js\";\nimport { Matrix3 } from \"../math/Matrix3.js\";\nimport { MathUtils } from \"../math/MathUtils.js\";\n\nlet _object3DId = 0;\n\nconst _v1 = new Vector3();\nconst _q1 = new Quaternion();\nconst _m1 = new Matrix4();\nconst _target = new Vector3();\n\nconst _position = new Vector3();\nconst _scale = new Vector3();\nconst _quaternion = new Quaternion();\n\nconst _xAxis = new Vector3(1, 0, 0);\nconst _yAxis = new Vector3(0, 1, 0);\nconst _zAxis = new Vector3(0, 0, 1);\n\nconst _addedEvent = { type: \"added\" };\nconst _removedEvent = { type: \"removed\" };\n\nfunction Object3D() {\n  Object.defineProperty(this, \"id\", { value: _object3DId++ });\n\n  this.uuid = MathUtils.generateUUID();\n\n  this.name = \"\";\n  this.type = \"Object3D\";\n\n  this.parent = null;\n  this.children = [];\n\n  this.up = Object3D.DefaultUp.clone();\n\n  const position = new Vector3();\n  const rotation = new Euler();\n  const quaternion = new Quaternion();\n  const scale = new Vector3(1, 1, 1);\n\n  function onRotationChange() {\n    quaternion.setFromEuler(rotation, false);\n  }\n\n  function onQuaternionChange() {\n    rotation.setFromQuaternion(quaternion, undefined, false);\n  }\n\n  rotation._onChange(onRotationChange);\n  quaternion._onChange(onQuaternionChange);\n\n  Object.defineProperties(this, {\n    position: {\n      configurable: true,\n      enumerable: true,\n      value: position,\n    },\n    rotation: {\n      configurable: true,\n      enumerable: true,\n      value: rotation,\n    },\n    quaternion: {\n      configurable: true,\n      enumerable: true,\n      value: quaternion,\n    },\n    scale: {\n      configurable: true,\n      enumerable: true,\n      value: scale,\n    },\n    modelViewMatrix: {\n      value: new Matrix4(),\n    },\n    normalMatrix: {\n      value: new Matrix3(),\n    },\n  });\n\n  this.matrix = new Matrix4();\n  this.matrixWorld = new Matrix4();\n\n  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n  this.matrixWorldNeedsUpdate = false;\n\n  this.layers = new Layers();\n  this.visible = true;\n\n  this.castShadow = false;\n  this.receiveShadow = false;\n\n  this.frustumCulled = true;\n  this.renderOrder = 0;\n\n  this.userData = {};\n}\n\nObject3D.DefaultUp = new Vector3(0, 1, 0);\nObject3D.DefaultMatrixAutoUpdate = true;\n\nObject3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: Object3D,\n\n  isObject3D: true,\n\n  onBeforeRender: function () {},\n  onAfterRender: function () {},\n\n  applyMatrix4: function (matrix) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    this.matrix.premultiply(matrix);\n\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  },\n\n  applyQuaternion: function (q) {\n    this.quaternion.premultiply(q);\n\n    return this;\n  },\n\n  setRotationFromAxisAngle: function (axis, angle) {\n    // assumes axis is normalized\n\n    this.quaternion.setFromAxisAngle(axis, angle);\n  },\n\n  setRotationFromEuler: function (euler) {\n    this.quaternion.setFromEuler(euler, true);\n  },\n\n  setRotationFromMatrix: function (m) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    this.quaternion.setFromRotationMatrix(m);\n  },\n\n  setRotationFromQuaternion: function (q) {\n    // assumes q is normalized\n\n    this.quaternion.copy(q);\n  },\n\n  rotateOnAxis: function (axis, angle) {\n    // rotate object on axis in object space\n    // axis is assumed to be normalized\n\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.multiply(_q1);\n\n    return this;\n  },\n\n  rotateOnWorldAxis: function (axis, angle) {\n    // rotate object on axis in world space\n    // axis is assumed to be normalized\n    // method assumes no rotated parent\n\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.premultiply(_q1);\n\n    return this;\n  },\n\n  rotateX: function (angle) {\n    return this.rotateOnAxis(_xAxis, angle);\n  },\n\n  rotateY: function (angle) {\n    return this.rotateOnAxis(_yAxis, angle);\n  },\n\n  rotateZ: function (angle) {\n    return this.rotateOnAxis(_zAxis, angle);\n  },\n\n  translateOnAxis: function (axis, distance) {\n    // translate object by distance along axis in object space\n    // axis is assumed to be normalized\n\n    _v1.copy(axis).applyQuaternion(this.quaternion);\n\n    this.position.add(_v1.multiplyScalar(distance));\n\n    return this;\n  },\n\n  translateX: function (distance) {\n    return this.translateOnAxis(_xAxis, distance);\n  },\n\n  translateY: function (distance) {\n    return this.translateOnAxis(_yAxis, distance);\n  },\n\n  translateZ: function (distance) {\n    return this.translateOnAxis(_zAxis, distance);\n  },\n\n  localToWorld: function (vector) {\n    return vector.applyMatrix4(this.matrixWorld);\n  },\n\n  worldToLocal: function (vector) {\n    return vector.applyMatrix4(_m1.getInverse(this.matrixWorld));\n  },\n\n  lookAt: function (x, y, z) {\n    // This method does not support objects having non-uniformly-scaled parent(s)\n\n    if (x.isVector3) {\n      _target.copy(x);\n    } else {\n      _target.set(x, y, z);\n    }\n\n    const parent = this.parent;\n\n    this.updateWorldMatrix(true, false);\n\n    _position.setFromMatrixPosition(this.matrixWorld);\n\n    if (this.isCamera || this.isLight) {\n      _m1.lookAt(_position, _target, this.up);\n    } else {\n      _m1.lookAt(_target, _position, this.up);\n    }\n\n    this.quaternion.setFromRotationMatrix(_m1);\n\n    if (parent) {\n      _m1.extractRotation(parent.matrixWorld);\n      _q1.setFromRotationMatrix(_m1);\n      this.quaternion.premultiply(_q1.inverse());\n    }\n  },\n\n  add: function (object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    if (object === this) {\n      console.error(\n        \"THREE.Object3D.add: object can't be added as a child of itself.\",\n        object\n      );\n      return this;\n    }\n\n    if (object && object.isObject3D) {\n      if (object.parent !== null) {\n        object.parent.remove(object);\n      }\n\n      object.parent = this;\n      this.children.push(object);\n\n      object.dispatchEvent(_addedEvent);\n    } else {\n      console.error(\n        \"THREE.Object3D.add: object not an instance of THREE.Object3D.\",\n        object\n      );\n    }\n\n    return this;\n  },\n\n  remove: function (object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n\n      return this;\n    }\n\n    const index = this.children.indexOf(object);\n\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n\n      object.dispatchEvent(_removedEvent);\n    }\n\n    return this;\n  },\n\n  attach: function (object) {\n    // adds object as a child of this, while maintaining the object's world transform\n\n    this.updateWorldMatrix(true, false);\n\n    _m1.getInverse(this.matrixWorld);\n\n    if (object.parent !== null) {\n      object.parent.updateWorldMatrix(true, false);\n\n      _m1.multiply(object.parent.matrixWorld);\n    }\n\n    object.applyMatrix4(_m1);\n\n    object.updateWorldMatrix(false, false);\n\n    this.add(object);\n\n    return this;\n  },\n\n  getObjectById: function (id) {\n    return this.getObjectByProperty(\"id\", id);\n  },\n\n  getObjectByName: function (name) {\n    return this.getObjectByProperty(\"name\", name);\n  },\n\n  getObjectByProperty: function (name, value) {\n    if (this[name] === value) return this;\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      const child = this.children[i];\n      const object = child.getObjectByProperty(name, value);\n\n      if (object !== undefined) {\n        return object;\n      }\n    }\n\n    return undefined;\n  },\n\n  getWorldPosition: function (target) {\n    if (target === undefined) {\n      console.warn(\n        \"THREE.Object3D: .getWorldPosition() target is now required\"\n      );\n      target = new Vector3();\n    }\n\n    this.updateMatrixWorld(true);\n\n    return target.setFromMatrixPosition(this.matrixWorld);\n  },\n\n  getWorldQuaternion: function (target) {\n    if (target === undefined) {\n      console.warn(\n        \"THREE.Object3D: .getWorldQuaternion() target is now required\"\n      );\n      target = new Quaternion();\n    }\n\n    this.updateMatrixWorld(true);\n\n    this.matrixWorld.decompose(_position, target, _scale);\n\n    return target;\n  },\n\n  getWorldScale: function (target) {\n    if (target === undefined) {\n      console.warn(\"THREE.Object3D: .getWorldScale() target is now required\");\n      target = new Vector3();\n    }\n\n    this.updateMatrixWorld(true);\n\n    this.matrixWorld.decompose(_position, _quaternion, target);\n\n    return target;\n  },\n\n  getWorldDirection: function (target) {\n    if (target === undefined) {\n      console.warn(\n        \"THREE.Object3D: .getWorldDirection() target is now required\"\n      );\n      target = new Vector3();\n    }\n\n    this.updateMatrixWorld(true);\n\n    const e = this.matrixWorld.elements;\n\n    return target.set(e[8], e[9], e[10]).normalize();\n  },\n\n  raycast: function () {},\n\n  traverse: function (callback) {\n    callback(this);\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  },\n\n  traverseVisible: function (callback) {\n    if (this.visible === false) return;\n\n    callback(this);\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  },\n\n  traverseAncestors: function (callback) {\n    const parent = this.parent;\n\n    if (parent !== null) {\n      callback(parent);\n\n      parent.traverseAncestors(callback);\n    }\n  },\n\n  updateMatrix: function () {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n\n    this.matrixWorldNeedsUpdate = true;\n  },\n\n  updateMatrixWorld: function (force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n\n      force = true;\n    }\n\n    // update children\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].updateMatrixWorld(force);\n    }\n  },\n\n  updateWorldMatrix: function (updateParents, updateChildren) {\n    const parent = this.parent;\n\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.parent === null) {\n      this.matrixWorld.copy(this.matrix);\n    } else {\n      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    }\n\n    // update children\n\n    if (updateChildren === true) {\n      const children = this.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateWorldMatrix(false, true);\n      }\n    }\n  },\n\n  toJSON: function (meta) {\n    // meta is a string when called from JSON.stringify\n    const isRootObject = meta === undefined || typeof meta === \"string\";\n\n    const output = {};\n\n    // meta is a hash used to collect geometries, materials.\n    // not providing it implies that this is the root object\n    // being serialized.\n    if (isRootObject) {\n      // initialize meta obj\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {},\n      };\n\n      output.metadata = {\n        version: 4.5,\n        type: \"Object\",\n        generator: \"Object3D.toJSON\",\n      };\n    }\n\n    // standard Object3D serialization\n\n    const object = {};\n\n    object.uuid = this.uuid;\n    object.type = this.type;\n\n    if (this.name !== \"\") object.name = this.name;\n    if (this.castShadow === true) object.castShadow = true;\n    if (this.receiveShadow === true) object.receiveShadow = true;\n    if (this.visible === false) object.visible = false;\n    if (this.frustumCulled === false) object.frustumCulled = false;\n    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n    if (JSON.stringify(this.userData) !== \"{}\") object.userData = this.userData;\n\n    object.layers = this.layers.mask;\n    object.matrix = this.matrix.toArray();\n\n    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n\n    // object specific properties\n\n    if (this.isInstancedMesh) {\n      object.type = \"InstancedMesh\";\n      object.count = this.count;\n      object.instanceMatrix = this.instanceMatrix.toJSON();\n    }\n\n    //\n\n    function serialize(library, element) {\n      if (library[element.uuid] === undefined) {\n        library[element.uuid] = element.toJSON(meta);\n      }\n\n      return element.uuid;\n    }\n\n    if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = serialize(meta.geometries, this.geometry);\n\n      const parameters = this.geometry.parameters;\n\n      if (parameters !== undefined && parameters.shapes !== undefined) {\n        const shapes = parameters.shapes;\n\n        if (Array.isArray(shapes)) {\n          for (let i = 0, l = shapes.length; i < l; i++) {\n            const shape = shapes[i];\n\n            serialize(meta.shapes, shape);\n          }\n        } else {\n          serialize(meta.shapes, shapes);\n        }\n      }\n    }\n\n    if (this.material !== undefined) {\n      if (Array.isArray(this.material)) {\n        const uuids = [];\n\n        for (let i = 0, l = this.material.length; i < l; i++) {\n          uuids.push(serialize(meta.materials, this.material[i]));\n        }\n\n        object.material = uuids;\n      } else {\n        object.material = serialize(meta.materials, this.material);\n      }\n    }\n\n    //\n\n    if (this.children.length > 0) {\n      object.children = [];\n\n      for (let i = 0; i < this.children.length; i++) {\n        object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n\n    if (isRootObject) {\n      const geometries = extractFromCache(meta.geometries);\n      const materials = extractFromCache(meta.materials);\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const shapes = extractFromCache(meta.shapes);\n\n      if (geometries.length > 0) output.geometries = geometries;\n      if (materials.length > 0) output.materials = materials;\n      if (textures.length > 0) output.textures = textures;\n      if (images.length > 0) output.images = images;\n      if (shapes.length > 0) output.shapes = shapes;\n    }\n\n    output.object = object;\n\n    return output;\n\n    // extract data from the cache hash\n    // remove metadata on each item\n    // and return as array\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n  },\n\n  clone: function (recursive) {\n    return new this.constructor().copy(this, recursive);\n  },\n\n  copy: function (source, recursive) {\n    if (recursive === undefined) recursive = true;\n\n    this.name = source.name;\n\n    this.up.copy(source.up);\n\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n\n    return this;\n  },\n});\n\nexport { Object3D };\n"]},"metadata":{},"sourceType":"module"}